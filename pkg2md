#!/usr/bin/env node

'use strict';

var cli = require('cli');
var path = require('path');
var fs = require('fs');
var constants = require('./lib/constants');
var PkgToMd = require('./lib/pkg-to-md');
var CliLogger = require('./lib/cli-logger');

var commander = require('commander');
var colors = require('colors');


///////////////////////////////////////////////////////////////////////////////
// CLI INIT
///////////////////////////////////////////////////////////////////////////////

/**
 * How to use the CLI.
 * @type {string}
 * @private
 */
var usage = path.basename(__filename) + ' [PKG-IN-FILE (default: package.json)] [MD-OUT-FILE (default: README.md)] [OPTIONS]'; // TODO usage!!!

/**
 * The path to package.json.
 * @type {string}
 * @private
 */
var packagePath = __dirname + '/package.json';

var packageData = JSON.parse(fs.readFileSync(packagePath, constants.UTF8));
var args = [];
var actionOrder = [];
commander
    .version(packageData.version)
    .description(packageData.description)

    // general options
    .option('-I, --pkg <package>', 'the package input file [' + constants.DEFAULT_PKG_FILE + ']', constants.DEFAULT_PKG_FILE)
    .option('-O, --md <markdown>', 'the Markdown output file [' + constants.DEFAULT_MD_FILE + ']', constants.DEFAULT_MD_FILE)
    .option('-T, --title <name>', 'another title to use as main headline instead of module \'name\' (single word only!) [name]', packageData.name)
    .option('-v, --validate', 'whether to validate the package.json file on input reading [false]')
    .option('-h, --headline <n>', 'the amount of basic headline indention: 1 => #, 2 => ##, ... [1]', 1)
    .option('-f, --force', 'force overwriting of existing output files on write phase: if an existing file is not overwritten (which is default), then the generated Markdown is simply appended [false]')

    // log options
    .option('-L, --level <level>', 'log level for CLI output (info|debug|trace|warn|error|fatal) [info]', /^(info|debug|trace|warn|error|fatal)$/i, 'info')
    .option('-R, --no-color', 'whether to print the log colorized [true]')
    .option('-S, --silent', 'whether to suppress any log [false]')

    // assembled sections
    .option('-t, --tests', 'whether to print the test execution section \'scripts.test\' [false]')
    .option('-i, --inst', 'whether to print the installation how-to [false]')

    // concrete properties
    .option('-s, --staff', 'whether to print the project\'s staff: \'author\', \'contributors\' and \'maintainers\' [false]')
    .option('-D, --no-desc', 'whether to print the \'description\' [true]')
    .option('-l, --lic', 'whether to print the \'license\' [false]')
    .option('-m, --main', 'whether to print the \'main\' executable file [false]')
    .option('--no-ver', 'whether to print the \'version\' in title headline [true]')
    .option('-d, --deps', 'whether to print the module library dependencies: \'dependencies\', \'devDependencies\', \'bundle(d)Dependencies\', \'optionalDependencies\', \'peerDependencies\' [false]')
    .option('-r, --repo', 'whether to print the \'repository\' [false]')
    .option('-k, --keywords', 'whether to print the \'keywords\' [false]')
    .option('-b, --bin', 'whether to print the binary mappings \'bin\' [false]')
    .option('-o, --os', 'whether to print the OS support \'os\' [false]')
    .option('-c, --cpu', 'whether to print the CPU support \'cpu\' [false]')
    .option('-C, --config', 'whether to print the NPM \'config\' [false]')
    .option('-S, --scripts', 'whether to print the NPM \'scripts\' [false]')
    .option('-e, --engines', 'whether to print the supported \'engines\' [false]')

    // special treatment for headline parsing, because commander does not allow
    // all 4 args in option() call (3rd arg is either a parse function or default value!)
    .on('headline', function (arg) {
        console.log('ARG headline PARSED: ' + arg);
        commander.headline = parseInt(arg);
    });

// .on('tests', createOrderEventHandler('tests'))
// .on('inst', createOrderEventHandler('inst'))
// .on('staff', createOrderEventHandler('staff'))

registerOrderEvents(['tests', 'inst', 'staff', 'lic', 'main', 'deps', 'keywords', 'bin', 'os', 'cpu', 'config', 'scripts', 'engines']);
commander.parse(process.argv);

function registerOrderEvents(argNames) {
    argNames.forEach(function (argName) {
        commander.on(argName, createOrderEventHandler(argName))
    });
}

function createOrderEventHandler(argName) {
    return function (argValue) {
        console.log('ARG ' + argName + ' PARSED: ' + argValue);
        actionOrder.push(argName);
    }
}

var cliLogger = new CliLogger({
    level: commander.level,
    noColor: !commander.color,
    silent: commander.silent
});

//console.log('OPTIONS::: ' + JSON.stringify(commander.options, null, 4));


cliLogger.trace('ORDER::: ' + JSON.stringify(actionOrder, null, 4));

// if (!process.argv.slice(2).length) {
//     commander.outputHelp(makeRed);
// }

// function makeRed(txt) {
//     return colors.red(txt); //display the help text in red on the console
// }

// write MD
var pkgToMd = new PkgToMd(cliLogger);
pkgToMd.writeMarkdown(commander, actionOrder)
    .then(function (msg) {
        cliLogger.info(msg);
    })
    .catch(function (err) {
        cliLogger.error('////////////////////////////////////////////////////////////////////////////////');
        cliLogger.error(err.stack);
        cliLogger.error('////////////////////////////////////////////////////////////////////////////////');
        commander.outputHelp(makeRed);
    });
